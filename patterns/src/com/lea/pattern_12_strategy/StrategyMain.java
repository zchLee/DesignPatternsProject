package com.lea.pattern_12_strategy;

/**
 * @author lzc
 * @create 2020-11-19 11:35
 * 策略模式是一种比较简单的模式,也叫政策模式（policy Pattern）
 *      定义一组算法，将每个算法都封装起来，并且使它们之间可以互换
 * 策略模式有三个角色：
 *      Context封装角色
 *          上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化
 *      Strategy抽象策略角色
 *          策略、算法家族的抽象，通常为接口，定义每一个策略或算法必须具有方法和属性。
 *      ConcreteStrategy具体策略角色
 *          实际抽象策略中的操作，该类含有具体的算法
 * 优点:
 *     算法可以自由切换：
 *          这是策略模式本身定义的，只要实现了抽象策略，它就成为策略家族的一个成员，通过封装对象对其进行封装
 *          保证对外提供自由切换的策略
 *     避免使用多重条件判断：
 *          使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口，就是封装类，
 *          简化了操作，同时避免了条件语句判断
 *     扩展性良好：
 *          如果要扩展，直接增加一个实现子类就可以。其他都不用修改，符合OCP原则
 *
 * 缺点：
 *     1. 策略类数量增多时，复用可能性小，类数量增多
 *     2. 所有的策略类都对外暴露，不符合迪米特原则。可以使用工厂方法模式、代理模式、享元模式
 *
 * 使用场景：
 *      1.多个类只有在算法或行为上稍有不同的场景
 *      2.算法需要自由切换的场景
 *      3.需要屏蔽算法规则的场景
 * 注意：
 *  如果一个系统中策略家族的具体策略数量超过了4个，则需要考虑使用混合模式，解决策略模式类膨胀和对外暴露的问题
 *  否则日后的系统维护就会成为一个烫手的山芋，谁都不想接
 *
 * 扩展：
 *      策略枚举 见 strategyenum 包
 *
 * 在实际项目中，我们一般通过工厂方法模式来实现策略类的声明
 */
public class StrategyMain {
}
