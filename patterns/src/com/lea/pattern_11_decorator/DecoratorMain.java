package com.lea.pattern_11_decorator;

/**
 * @author lzc
 * @create 2020-11-19 09:43
 * 装饰模式（Decorator）
 *      动态地给一个对象增加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活
 *  在装饰模式中，有四个角色需要说明
 *      1.Component 抽象构件：
 *          是一个接口或者抽象类，就是定义我们最核心的对象，也就是最原始的对象
 *  注意点：在装饰器中必然有一个最基本、最核心、最原始的接口或抽象类Component抽象构件
 *      2.ConcreteComponent 具体构件：
 *          ConcreteComponent具体构件是最基本、最核心、最原始的接口或抽象类的实现，装饰模式装饰的就是这个对象
 *      3、Decorator 装饰角色
 *          一般是一个抽象类，做什么用呢？实现接口或抽象方法，它里面不一定有抽象方法，在
 *          它的属性里必然有一个private变量指向Component抽象构件
 *      4.ConcreteDecorator 具体装饰类
 *          把最核心、最基本的东西装饰成其他东西
 *
 *  装饰类的优点：
 *      1.装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无需知道Decorator类，Decorator
 *      是从外部来扩展Component类的功能，而Decorator也不用知道具体的构建
 *      2.装饰模式是继承关系的一个替代方案。从案例中看出，不管装饰多少层，返回的对象都是Component，实现的
 *      还是is-a的关系
 *      3.装饰类可以动态的扩展一个实现类的功能。
 *  缺点：
 *      多层的装饰是比较复杂的。当一层一层往下debug发现是最底层出现问题了， 得多心塞。
 *      所以尽可能减少装饰类的数量，以便降低系统的复杂度。
 *
 *  使用场景：
 *      需要扩展一个类的功能，或给一个类增加附加功能
 *      需要动态地给一个类增加功能，这些功能可以再动态地撤销
 *      需要为一批兄弟类进行改装或加装功能，当然首选装饰模式
 *
 *
 *
 */
public class DecoratorMain {
}
