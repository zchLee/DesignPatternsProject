package com.lea.pattern_17_facade;

/**
 * @author lzc
 * @create 2020-11-25 10:15
 * 门面模式也加做外观模式 【常用】
 *      要求一个子系统与其内部的通信必须通过一个统一的对象进行。
 *      门面模式提供一个高层次的接口，使得子系统更易于维护。
 * 门面系统注重“统一对象”，也就是提供一个访问子系统的接口，除了这个接口不允许有任何访问子系统的行为发生，做到不管
 * 内部子系统多不复杂，只要有门面对象在就可以做到“金玉其外，败絮其中”
 *
 * 门面模式的角色：
 *  Facade 门面角色
 *      客户端可以调用这个角色方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求
 *      委派到相应的子系统去，可以看做该角色没有实际的业务逻辑，只是一个委托类
 *  subsystem 子系统角色
 *      可以同时有一个或多个子系统。每个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在，
 *      对于子系统而言，门面仅仅是个客户端而已
 * 优点：
 *  1.减少系统的相互依赖，解决外界与子系统的强耦合关系，所有依赖都是面对门面的依赖，与子系统无关
 *  2.提高灵活性，依赖少了，灵活性自然提高了，不管子系统怎么变化，只要不影响门面对象，随便弄
 *  3.提高安全性，只能访问门面提供的方法
 * 缺点：
 *  1.门面模式最大的缺点是不符合开闭原则，对修改关闭，对扩展开放。
 *
 * 使用场景：
 *  1.为一个复杂的子系统或模块提供一个供外界访问的接口
 *  2.子系统相对独立，外界对子系统的访问只要黑箱操作即可
 *  3.预防低水平人员带来的风险
 *
 * 注意事项：
 *  1.一个子系统可以有多个门面
 *      一般情况下，一个子系统有一个门面就够了，什么时候分呢？
 *      1.1 门面已经庞大到不能忍受的程度
 *          代码超过200行时，建议按照功能拆分
 *      1.2 子系统可以提供不同访问路径
 *          有模块受限访问对象，只能访问一个对外发布的方法时，应该建立两个门面，供不同的高层模块来访问
 *      1.3 门面不参与子系统内的业务逻辑
 *          在门面methodC方法中增加doSomethingA方法，行不行？
 *          不行。一个门面不应该参与子系统的逻辑业务，门面对象只提供一个访问子系统的一个路劲而已，它不应该参与
 *          具体的业务逻辑，否则就会产生一个倒依赖问题：子系统必须依赖门面对象才能访问。这破坏了系统的封装性，
 *          同时也违背了单一职责
 */
public class FacadeMain {
}
