package com.lea.pattern_19_visitor;

/**
 * @author lzc
 * @create 2020-11-27 09:51
 * 访问者模式
 *  封装一些作用于某种数据结构中的各元素的操作，它可以在不改变元素的前提下定义这些元素新的操作
 *
 * 访问者的各个角色
 *  Visitor----抽象访问者
 *      抽象类或者接口，声明访问者可以访问那些元素，具体到程序中就是visitor方法的参数定义那些对象可以被访问
 *  ConcreteVisitor----具体访问者
 *      它影响访问者访问到一个元素后怎么干，要做什么事情
 *  Element----抽象元素
 *      接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept访问中的参数来定义的
 *  ConcreteElement----具体抽象者
 *      实现accept方法，通常是visitor.visitor(this), 基本上形成了一种模式
 *  ObjectStructural----结构对象
 *      元素产生者，一般容纳多个不同类、不同接口的容器，如List、Set、Map等
 *
 * 优点：
 *      1.符合单一职责，访问者只对数据进行展示
 *      2.优秀的扩展性，由于职责分开，继续增加对数据的操作非常快捷
 *      3.灵活度很高
 * 缺点：
 *      1.具体元素对访问者公布细节，访问者关注了其他类的内部细节，这是迪米特法则不允许的
 *      2、具体元素变更困难
 *          具体元素要增加字段后，访问者就要做对应的修改
 *      3.违背了依赖倒置原则
 *          访问者依赖的是具体元素，而不是抽象元素，破坏了依赖倒置原则，
 *          在面向对象编程时，抛弃了对接口的依赖，而直接依赖实现类，扩展困难
 *
 * 使用场景
 *      1.一个对象接口包含很多类对象，他们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作
 *      迭代器模式已经不能胜任的场景
 *      2.需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作污染 这些对象的时候
 *
 *    总结：当业务规则要求遍历多个不同对象。这本身也是访问者模式出发点，迭代器模式只能访问同类或同接口的数据
 *    而访问者是对迭代器的扩充，可以遍历不同的元素，不同的操作，也就是针对访问的对象不同，执行的操作不同
 *    访问者还有一个用途，就是充当拦截器（Interceptor）角色
 */
public class VisitorMain {

}
